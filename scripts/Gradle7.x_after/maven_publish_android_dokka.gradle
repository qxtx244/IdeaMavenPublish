import org.gradle.api.internal.artifacts.DefaultExcludeRule

/**
 * 实现上传到maven仓库，适用于android library，并且同时支持java和kotlin语言，支持生成javadoc/html/markdown等类型的api文档，是纯kotlin/java&kotlin混合项目的首选脚本。
 *
 * 此脚本仅适用于Gradle7.x或更高版本。
 *
 * > 基本概念
 *   android library：引入了com.android.application或com.android.library插件的module
 *   java library：未引入com.android.application或com.android.library插件的module，使用java/groovy语言编写的项目
 *
 * > 环境配置方法：
 *   1. 在根工程build.gradle的顶部添加如下代码（buildscript闭包必须位于文件顶部）：
 *      buildscript {
 *         dependencies {
 *             //添加kotlin gradle插件
 *             classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.21'
 *             //不要使用更高版本，高版本AGP可能不兼容高版本的dokka插件
 *             classpath 'org.jetbrains.dokka:dokka-gradle-plugin:1.6.10'
 *         }
 *      }
 *      //Gradle7.x以上版本的新的添加classpath的写法暂时省略，旧写法也通用的。不然太乱了
 *   2. 在module的build.gradle中添加：
 *      dependencies {
 *         implementation 'androidx.core:core-ktx:1.7.0'   //添加这一行，版本可自选
 *      }
 *
 * > 使用步骤：
 *   因为需要一些AGP插件中的变量，因此以下代码必须在android{}之后配置，尽量放到build.gradle的最后面。
 *   1. 在目标module的build.gradle中的末尾添加代码：
 *      //可选配置。一般只需要配置maven仓库地址和版本名称即可，其它参数会尝试自动获取。
 *      ext {
 *          //pomMavenCentral = 'maven仓库地址'
 *          //pomVersionName = '1.0.0'
 *          //pomJavaDoc = 'true'
 *          //pomHtmlDoc = 'true'
 *          ...
 *      }
 *
 *      apply from: '这个文件的路径（右键文件-》CopyPath即可复制文件路径，注意转义符）'   //这行代码是必须的
 *   2. 检查build.gradle中的参数配置是否正确（比如maven仓库地址，版本名称等，groupId，artifactId等）；
 *   3. sync工程，然后build构建项目，执行assemble打包项目，以生成jar/aar包；
 *   4. 点击展开AS右侧的"Gradle"面板，依次展开 module名称 》Tasks》publishing，双击执行"publish"任务，等待执行完成。
 *   注意1：发布到snapshots仓库，版本名称必须在末尾加上“-SNAPSHOT”后缀，否则发布请求将会被远程仓库拒绝。
 *   注意2：相同的release版本禁止重复发布。
 *
 * > 参数配置说明：
 *   允许在外部提前配置以下参数，可使用的ext变量如下（在build.gradle中配置：ext.xxx = yyy）
 *   pomMavenAccount   maven账户信息，ArrayList<String>类型，格式：['USER', 'PASSWORD']
 *   pomMavenCentral   maven仓库地址，String类型
 *   pomGroupId         String类型，组id。通常使用module包名
 *   pomArtifactId     String类型，artifactId。通常使用module名称，即project.name
 *   pomVersionName    String类型，版本名称。发布到snapshots仓库需要在末尾加上'-SNAPSHOT'
 *   pomDesc             描述信息，String类型
 *   pomSrcDirs         源码目录，ArrayList<String>类型，格式：['a/b/x', 'a/b', ...]
 *   pomBuildType       发布的构建版本，String类型。取值为“debug”或“release”，对应debug和release的jar/aar包
 *   pomJavaDocEnable  是否发布javaDoc，取值为"true"或"false"
 *   pomHtmlDocEnable  是否发布htmlDoc，取值为"true"或"false"
 *   pomSourceEnable   是否发布源码，取值为"true"或"false"
 *   pomBuildFilePath  库打包文件的绝对路径。如"xxx/1.jar"，"xxx/xx/1.aar"；
 *                         如果配置此项，则pomBuildType配置将会被忽略；
 *                         如果未配置此项，则自动寻找library输出的pomBuildType版本的aar文件。
 */

buildscript {
    repositories {
        google()
        mavenCentral()
    }
}

apply plugin: 'kotlin-android'
apply plugin: 'org.jetbrains.dokka'
apply plugin: 'maven-publish'

/**
 * 让dokka在离线模式下工作，防止一直下载不了东西导致耗时超长
 * 无法下载：https://developer.android.com/reference/androidx/package-list
 */
private def doOffline(def task) {
    //让dokka离线工作，防止一直下不了东西导致耗时超长
    task.offlineMode = true
    task.dokkaSourceSets {
        try {
            named('main') { t ->
                t.noAndroidSdkLink = true
                t.noJdkLink = true
                t.noStdlibLink = true
            }
        } catch (Exception e) {
            e.printStackTrace()
        }
    }
}
dokkaHtml.each {doOffline(it) }
dokkaJavadoc.each { doOffline(it) }
dokkaGfm.each { doOffline(it) }
dokkaJekyll.each { doOffline(it) }

/**
 * 获取是否允许发布源码。如果未配置，默认返回true
 * @return true表示发布，否则不发布
 */
private boolean isSourceEnable() {
    def ret = getPomExt("pomSourceEnable")
    if (ret == null) ret = 'true'
    ret.toLowerCase() == 'true'
}

/**
 * 获取是否发布htmlDoc。如果未配置，默认返回true
 * @return true表示发布，否则不发布
 */
private boolean isHtmlDocEnable() {
    def ret = getPomExt("pomHtmlDocEnable")
    if (ret == null) ret = 'true'
    ret.toLowerCase() == 'true'
}

/**
 * 获取是否发布javaDoc。如果未配置，默认返回true
 * @return true表示发布，否则不发布
 */
private boolean isJavaDocEnable() {
    def ret = getPomExt("pomJavaDocEnable")
    if (ret == null) ret = 'true'
    ret.toLowerCase() == 'true'
}

/**
 * 发布版本，取值为“debug”或“release”，对应debug和release的jar/aar包。预设返回“release”
 */
private String getPomBuildType() {
    def type = getPomExt("pomBuildType")
    if (type != "release" && type != "debug") type = "release"
    return type 
}

/**
 * 获取外部指定的构建版本文件路径。如果获取到有效值，则忽略pomBuildType配置。
 */
private String getPomBuildFilePath() {
    String path = getPomExt("pomBuildFilePath")
    if (path == null) path = findAarPath(getPomBuildType())
    if (path == null) throw new Exception("无法找到构建输出的文件！")
    return path
}

/**
 * 获取maven私服验证信息，即账户和密码。如果为null，则表示不需要使用账户密码
 * @return 账户和密码
 */
private ArrayList<String> getPomMavenAccount() {
    getPomExt("pomMavenAccount")
}

/**
 * 获取maven仓库地址，如果ext未定义，使用本地maven仓库
 * @return maven仓库地址
 */
private String getPomMavenCentral() {
    def url = getPomExt("pomMavenCentral")
    if (url == null) url = "${rootDir.absolutePath}/.mavenCentral"
    if (url == null) throw new Exception("无法获取maven仓库地址！")
    url.toString()
}

/**
 * 获取groupId，如果ext未定义，则默认获取AndroidManifest.xml中定义的包名
 * @return groupId
 */
private String getPomGroupId() {
    def groupId = null
    try {
        groupId = getPomExt("pomGroupId")
        if (groupId == null) {
            def slurper = new XmlSlurper()
            def file = file('src/main/AndroidManifest.xml')
            if (file.exists()) {
                def result = slurper.parse(file)
                groupId = result['@package']
            }
        }
        if (groupId == null) throw Exception("无法获取groupId！")
        groupId = groupId.toString().replaceAll('/', '\\.').replaceAll('\\\\', '\\.')
    } catch (Exception e) {
        e.printStackTrace()
    }
    groupId.toString()
}

/**
 * 获取artifactId，如果ext未定义，则使用project名称
 * @return artifactId
 */
private String getPomArtifactId() {
    def artifactId = getPomExt("pomArtifactId")
    if (artifactId == null) artifactId = project.name
    if (artifactId == null) throw Exception("无法获取artifactId！")
    artifactId.toString()
}

/**
 * 获取versionName，如果ext中未定义，则默认获取defaultConfig中定义的versionName
 * @return versionName
 */
private String getPomVersion() {
    def versionName = getPomExt("pomVersionName")
    if (versionName == null) {
        versionName = android.defaultConfig.versionName
        if (versionName == null) {
            versionName = '1.0.0'
        }
    }
    if (versionName == null) throw Exception("无法获取versionName！")
    versionName.toString()
}

/**
 * 获取描述信息
 * 如果ext未定义，则为空
 * @return 描述信息
 */
private String getPomDesc() {
    def desc = getPomExt("pomDesc")
    if (desc == null) desc = ''
    desc.toString()
}

/**
 * 获取源码目录，如果ext未定义，则取main中的默认资源目录
 * @return 可能为null
 */
private ArrayList<String> getPomSrcDirs() {
    def dirs = getPomExt("pomSrcDirs")
    if (dirs == null) dirs = android.sourceSets.main.java.srcDirs
    dirs
}

private def getPomExt(String name) {
    def extMap = getExtensions().extraProperties
    if (extMap.has(name)) return extMap.get(name)
    null
}

/**
 * 使用dokka生成javaDoc文档，并打包成jar
 */
task javadocsJar(type: Jar, dependsOn: dokkaJavadoc, group: 'extension') {
    getArchiveClassifier().set('javadoc')
    def dirList = new ArrayList()
    dokkaJavadoc.each {dokkaTask ->
        //让dokka离线工作，防止一直下不了东西导致耗时超长
        dokkaTask.offlineMode = true
        dokkaTask.dokkaSourceSets {
            named('main') {t ->
                t.noAndroidSdkLink = true
                t.includeNonPublic = false
                t.skipEmptyPackages = false
                t.reportUndocumented = false
                t.skipDeprecated = false
            }
        }

        def path = dokkaTask.outputDirectory.get().absolutePath
        println "dokkaJavaDoc输出目录：$path"
        dirList.add(path)
    }

    from dirList

    doLast {
        println "dokkaJavaDoc jar输出目录：${Arrays.toString(dirList.toArray(new String[0]))}"
    }
}

/**
 * 使用dokka生成html文档，并打包成jar
 */
task htmlDocJar(type: Jar, dependsOn: dokkaHtml, group: 'extension') {
    getArchiveClassifier().set('html-doc')
    def dirList = new ArrayList()
    dokkaHtml.each { dokkaTask ->
        //让dokka离线工作，防止一直下不了东西导致耗时超长
        dokkaTask.offlineMode = true
        dokkaTask.dokkaSourceSets {
            named('main') {t ->
                t.noAndroidSdkLink = true
                t.includeNonPublic = false
                t.skipEmptyPackages = false
                t.reportUndocumented = false
                t.skipDeprecated = false
            }
        }
        //org.jetbrains.dokka.gradle.DokkaTask
        def path = dokkaTask.outputDirectory.get().absolutePath
        println "dokkaHtml输出目录：$path"
        dirList.add(path)
    }
    from dirList

    doLast {
        println "dokkaHtml jar输出目录：${Arrays.toString(dirList.toArray(new String[0]))}"
    }
}

/**
 * 打包源码成jar
 */
task sourcesJar(type: Jar, group: 'extension') {
    getArchiveClassifier().set('sources')
    from getPomSrcDirs()
    doLast {
        println "源码jar输出目录：${getDestinationDirectory().getAsFile().get().absolutePath}"
    }
}

/** 需要认证的maven仓库url */
def CREDENTIAL_CENTRAL_URL = "xxx"
/** 认证账户 */
def CREDENTIAL_USER = "yyy"
/** 认证密码 */
def CREDENTIAL_PASSWORD = "zzz"

afterEvaluate {
    publishing {
        publications {
            register(project.name, MavenPublication.class) {
                println("${project.name}发布配置：" + 
                        "\nmaven仓库：${getPomMavenCentral()}" +
                        "\ngroupId=${getPomGroupId()}" +
                        "\nartifactId=${getPomArtifactId()}" +
                        "\nversion=${getPomVersion()}" +
                        "\nbuildType=${getPomBuildType()}" + 
                        "\ndesc=${getPomDesc()}" + 
                        "\njavadoc？${isJavaDocEnable()}" +
                        "\nhtmldoc？${isHtmlDocEnable()}")

                groupId       getPomGroupId()
                artifactId   getPomArtifactId()
                version       getPomVersion()
                description  getPomDesc()

                def filePath = getPomBuildFilePath()
                if (filePath != null) {
                    println "构建输出文件路径：${filePath}"
                    artifact(filePath)
                }

                if (isSourceEnable()) {
                    artifact(sourcesJar)
                }

                if (isJavaDocEnable()) {
                    artifact(javadocsJar)
                }

                if (isHtmlDocEnable()) {
                    artifact(htmlDocJar)
                }

                //添加三方依赖
                pom.withXml {
                    //三方依赖项
                    //<dependencies>
                    //  ...
                    //  <dependency>
                    //      <groupId>x.x.x</groupId>
                    //      <artifactId>yyy</artifactId>
                    //      <version>z.z.z</version>
                    //      <scope>compile|runtime</scope>
                    //      <type>jar/war/aar/pom等等，默认jar</type>
                    //  </dependency>
                    //  ...
                    //</dependencies>
                    def depNode = asNode().appendNode('dependencies')
                    try {
                        configurations.api.allDependencies.each { dependency ->
                            def node = addDependencyNode(depNode, dependency)
                            if (node != null) {
                                node.appendNode('scope', 'compile')

                                //排除的依赖项
                                addExclusionNode(dependency, node)
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace()
                    }

                    //不考虑test
                    //不考虑assembleDebug，只考虑assembleRelease
                    ArrayList<String> list = new ArrayList<>()
                    //找到执行的task名称列表
                    gradle.startParameter.taskRequests.each { request ->
                        list.addAll(request.args)
                    }
                    if (!list.isEmpty()) {
                        if (list.contains('assembleRelease')) {
                            try {
                                configurations.releaseApi.allDependencies.each { dependency ->
                                    def node = addDependencyNode(depNode, dependency)
                                    if (node != null) {
                                        node.appendNode('scope', 'compile')
                                        addExclusionNode(dependency, node)
                                    }
                                }
                            } catch (Exception e) {
                                e.printStackTrace()
                            }
                        }
                    }
                }
            }
        }

        repositories {
            maven {
                def centralUrl = getPomMavenCentral()
                url { uri(centralUrl) }
                def info = getPomMavenAccount()
                if (info != null) {
                    credentials {
                        username info[0]
                        password info[1]
                    }
                } else {
                    if (centralUrl.startsWith(CREDENTIAL_CENTRAL_URL)) {
                        //println "默认maven仓库，使用预置的账号认证"
                        credentials {
                            username CREDENTIAL_USER
                            password CREDENTIAL_PASSWORD
                        }
                    }
                }
                allowInsecureProtocol true
            }
        }
    }
}

/**
 * 排除的依赖项
 * <dependency>
 *  ...
 *  <exclusions>
 *      <exclusion>
 *          <groupId>xxx</groupId>
 *          <artifactId>xxx</artifactId>
 *      </exclusion>
 *  </exclusions>
 *  ...
 * </dependency>
 */
private def addExclusionNode(Dependency dependency, def dependencyNode) {
    HashSet<DefaultExcludeRule> set = dependency.excludeRules
    if (set != null && !set.isEmpty()) {
        def exclusionNode = dependencyNode.appendNode('exclusions')
        set.each { rule ->
            //println "添加依赖排除项：${rule.group}:${rule.module}"
            def excludeNode = exclusionNode.appendNode('exclusion')
            excludeNode.appendNode('groupId', rule.group)
            excludeNode.appendNode('artifactId', rule.module)
        }
    }
}

private def addDependencyNode(def dependencyNode, Dependency dependency) {
    def node = null
    if (dependency.name != 'unspecified' && dependency.group != null
            && dependency.version != null && dependency.version != 'unspecified') {
        //println "dept name=${dependency.name}, group=${dependency.group}, version=${dependency.version}"
        node = dependencyNode.appendNode('dependency')
        node.appendNode('groupId', dependency.group)
        node.appendNode('artifactId', dependency.name)
        node.appendNode('version', dependency.version)
    }
    node
}

/**
 * 找到指定构建版本的aar文件输出路径
 * @param buildType 构建版本，取值为"release"或"debug"
 */
private def findAarPath(String buildType) {
    String aarPath = null
    android.libraryVariants.all { variant ->
        variant.outputs.all { output ->
            if (variant.name == buildType && outputFileName.endsWith(".aar")) {
                def destDir = variant.getPackageLibrary().destinationDir
                aarPath = "${destDir.absolutePath}/${outputFileName}"
            }
        }
    }
    aarPath
}